🔴 TIER 1 — MANDATORY (biggest gains)

    1️- Separate simulation and render data

        ❌ Don’t render from dustBody
        ✅ Render from a position-only buffer

        Render buffer:
        vec4 position OR vec3 position

    2️- Vertex shader reads ONLY position

        Your vertex shader should:
            Read one contiguous position
            Do one matrix multiply
            Set gl_PointSize

        No:
            velocity
            mass
            radius
            conditionals
            math-heavy logic

    3️- Point size = 1

        gl_PointSize = 1.0;
        Anything larger explodes fragment cost.

    4️- Disable expensive fixed-function stages

        Unless absolutely required:
            glDisable(GL_BLEND);
            glDisable(GL_DEPTH_TEST);
            glDisable(GL_MULTISAMPLE);

    5️- Single draw call

        glDrawArrays(GL_POINTS, 0, count);

        No instancing tricks needed.

🟠 TIER 2 — HIGH IMPACT OPTIMIZATIONS

    6️- GPU-side culling

        Never draw what you can’t see.
        Simple vertex shader clip
    
        if (pos.x < -1 || pos.x > 1 ||
            pos.y < -1 || pos.y > 1 ||
            pos.z < -1 || pos.z > 1)
        {
            gl_Position = vec4(2,2,2,1);
            return;
        }


        Better:
            Compute shader culling
            Compact visible particles
            Culling 90% = ~10× speedup

    7️- Depth-aware ordering (if depth test enabled)

        If depth is needed:
            Sort front-to-back (once or occasionally)
            Reduces overdraw massively

    8️- Frustum-aware density

        At distance:
            Render fewer points
            Increase spacing
            Human eye won’t notice.

🟡 TIER 3 — MEMORY BANDWIDTH OPTIMIZATION

    9️- Structure of Arrays (SoA)

        Instead of:
            vec4 pos;

        Use:
            float posX[];
            float posY[];
            float posZ[];


        Benefits:
            Better cache locality
            Lower wasted reads
            Only worth it at 5–10M+ points

    10- Tighter data packing

        You don’t need 32-bit floats for dust.

        Options:
            half (16-bit floats)
            int16 normalized
            Quantized space coordinates

        Example:
            vec3 pos = unpackHalf3x16(packedPos);

    11- Persistent mapped buffers

        If CPU uploads are needed:
            Use persistent mapping
            Avoid glBufferSubData

🟢 TIER 4 — ADVANCED GPU PIPELINE

    1️2- Compute shader driven pipeline

        Compute updates simulation
        Writes directly to render buffer
        No CPU sync

    1️3- Draw indirect

        Use:
            glDrawArraysIndirect

        After GPU culling & compaction.
        Zero CPU involvement.

    1️4- Temporal dithering

        Draw 1/N particles per frame
        Jitter selection each frame
        Looks continuous, costs less.

    1️5- Multi-pass dust illusion

        Render:
            Near dense dust
            Far sparse dust
            Skybox dust texture
            Fake infinity.

🔵 TIER 5 — RARE BUT POWERFUL

    1️6- Early-Z tricks

        Depth pre-pass
        Hierarchical Z culling
        Mostly useful if blending is unavoidable.

    1️7- Custom raster (no GL_POINTS)

        Billboard quads via mesh shaders
        Hardware culling
        GPU-generated geometry
        Modern GPUs only.