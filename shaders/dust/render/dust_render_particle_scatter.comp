#version 450
layout(local_size_x = 256) in;

struct DustChunk {
    vec3 center;
    float radius;
    uint start;
    uint count;
    uint _pad0;
    uint _pad1;
};

layout(std430, binding = 1) buffer RenderBuffer {
    vec4 renderPos[];
};

layout(std430, binding = 2) buffer VisibleBuffer {
    vec4 visiblePos[];
};

layout(std430, binding = 3) buffer ChunkBuffer {
    DustChunk chunks[];
};

layout(std430, binding = 5) buffer ChunkVisible {
    uint chunkVisible[];
};

layout(std430, binding = 4) buffer VisibleCount {
    uint visibleCount;
};

uniform mat4 u_ViewProjection;
uniform vec3 u_CameraPos;
uniform float u_MaxDistance;
uniform float u_FarDistance;
uniform uint u_FrameOffset;

void main()
{
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= renderPos.length()) return;

    // Find which chunk this particle belongs to
    uint chunkId = gid / 256;
    if (chunkId >= chunks.length()) return;

    // Skip if chunk is culled
    if (chunkVisible[chunkId] == 0) return;

    DustChunk c = chunks[chunkId];
    
    // Verify particle is actually in this chunk's range
    if (gid < c.start || gid >= c.start + c.count) return;

    vec3 pos = renderPos[gid].xyz;
    float dist = length(pos - u_CameraPos);

    // Distance culling
    if (dist > u_MaxDistance) return;

    // LOD: Skip some particles at far distances
    if (dist > u_FarDistance && ((gid + u_FrameOffset) % 4 != 0)) return;

    // Frustum culling per-particle (fine-grained)
    vec4 clip = u_ViewProjection * vec4(pos, 1.0);
    if (clip.x < -clip.w || clip.x > clip.w ||
        clip.y < -clip.w || clip.y > clip.w ||
        clip.z < 0.0 || clip.z > clip.w)
        return;

    // Add to visible list
    uint index = atomicAdd(visibleCount, 1);
    if (index < visiblePos.length()) {
        visiblePos[index] = vec4(pos, 1.0);
    }
}