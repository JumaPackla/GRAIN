Ok anything else

Short answer: yeah — a few important “next-level” things, but nothing urgent or broken. You’re already doing a lot right. Think of these as polish + future-proofing, not fixes.

I’ll keep this tight and practical ??

1?? Stop calling glGetUniformLocation every frame (big win)

Right now you do this everywhere:

glUniformMatrix4fv(
    glGetUniformLocation(shader->getProgram(), "u_ViewProjection"),
    1, GL_FALSE, glm::value_ptr(vp)
);


That lookup is string-based + slow.

? Do this instead

Cache uniform locations once inside your Shader class:

int Shader::getUniform(const std::string& name)
{
    auto it = uniformCache.find(name);
    if (it != uniformCache.end())
        return it->second;

    int loc = glGetUniformLocation(program, name.c_str());
    uniformCache[name] = loc;
    return loc;
}


Then:

glUniformMatrix4fv(shader->getUniform("u_ViewProjection"), 1, GL_FALSE, ...);


?? This matters a lot at scale.

2?? Add a single frame boundary barrier

You currently sprinkle barriers everywhere (which is correct), but you should also have one authoritative “frame end” barrier.

At the end of update():

glMemoryBarrier(GL_ALL_BARRIER_BITS);


Why?

Makes frame ordering crystal-clear

Prevents subtle race conditions when you expand later

Costs basically nothing compared to a bug hunt

3?? Name your GPU objects (debug sanity)

When something breaks in RenderDoc or NSight, unnamed buffers are pain.

glObjectLabel(GL_BUFFER, ssbo, -1, "Dust Particle SSBO");
glObjectLabel(GL_PROGRAM, program, -1, "Dust Apply Forces CS");


This will save you hours later.

4?? Separate “simulation time” from “render time” (you’re almost there)

You already have this:

Time::control(dt)


Go one step further:

Fixed timestep for compute

Variable timestep for camera / input

Example:

constexpr float SIM_DT = 1.0f / 120.0f;

accumulator += dt;
while (accumulator >= SIM_DT)
{
    runDustSimulation(SIM_DT);
    accumulator -= SIM_DT;
}


This stabilizes:

Gravity

Integrators

GPU determinism

5?? Validate compute dispatch sizes (future crash prevention)

Before dispatch:

GLint maxGroups[3];
glGetIntegeri_v(GL_MAX_COMPUTE_WORK_GROUP_COUNT, 0, &maxGroups[0]);

assert(groups <= maxGroups[0]);


This prevents silent no-ops on lower-end GPUs.

6?? Indirect draw debugging toggle (you’ll want this)

Add a debug mode:

if (debugDisableCulling)
{
    dustPoints1->drawAll();
}
else
{
    dustPoints1->draw();
}


When particles disappear, this tells you instantly:

culling bug

or simulation bug

7?? One architectural suggestion (optional but ??)

You’re at the point where this should exist:

class DustSystem
{
public:
    void update(float dt, const Camera& camera);
    void render(const Camera& camera);

private:
    // all dust shaders, SSBOs, logic
};


Why this matters:

Application stops being a god-object

You can reuse dust in multiple scenes

Compute pipelines stay contained

8?? Reality check (important)

Nothing you posted screams “wrong” or “hacky”.

Honestly?

Your compute ? cull ? scatter ? indirect ? draw flow is engine-level

You’re already past most OpenGL tutorials

The bugs you’re hitting now are type system + scaling issues

That’s a good sign ??

If you want, next good steps would be:

GPU gravity math review

SSBO layout validation

Making this Vulkan-ready

Frame graph design

Just tell me where you wanna push it next ??